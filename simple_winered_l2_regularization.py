# -*- coding: utf-8 -*-
"""Simple  WineRed_L2_regularization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1I3PaC1l0i5nwJGmFuGdxep-wTJKSsDM4
"""

import pandas as pd

# %cd "/content/gdrive/MyDrive/Machine Learning/deliver/M2/"
df_wine = pd.read_csv('winequality-red.csv')

# Commented out IPython magic to ensure Python compatibility.
from numpy.random import seed
seed(8)
import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from sklearn import datasets, model_selection 
# %matplotlib inline

from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, BatchNormalization, Dropout
from tensorflow.keras import regularizers
from tensorflow.keras import callbacks

from sklearn.preprocessing import StandardScaler

#check the data
#df_wine['class'] = df_wine['class'].astype('float32')
#df_wine['class'] = df_wine['class'] * 5.0
#df_wine.head(10)
#df_wine['class'].unique()
#df_wine['class'].count()
#df_wine.isna().sum()
#df_wine.shape


# Complete the following function. 
# Make sure to not change the function name or arguments.

def read_in_and_split_data(df_data):
    """
    This function takes the Iris dataset as loaded by sklearn.datasets.load_iris(), and then 
    splits so that the training set includes 90% of the full dataset, with the test set 
    making up the remaining 10%.
    Your function should return a tuple (train_data, test_data, train_targets, test_targets) 
    of appropriately split training and test data and targets.
    
    If you would like to import any further packages to aid you in this task, please do so in the 
    Package Imports cell above.
    """
    train_df, test_df = train_test_split(df_data, test_size = 0.2)
    return (train_df, test_df)

# Run your function to generate the test and training data.
train_df, test_df = read_in_and_split_data(df_wine)

"""We will now convert the training and test targets using a one hot encoder."""

# Get Train set and Test set
train_targets = train_df['class']
train_data = train_df.loc[:, train_df.columns!='class']

test_targets = test_df['class']
test_data = test_df.loc[:, test_df.columns!='class']

train_data.shape[1]

"""#### Build the neural network model

You can now construct a model to fit to the data. Using the Sequential API, build your model according to the following specifications:

* The model should use the `input_shape` in the function argument to set the input size in the first layer.
* The first layer should be a dense layer with 64 units.
* The weights of the first layer should be initialised with the He uniform initializer.
* The biases of the first layer should be all initially equal to one.
* There should then be a further four dense layers, each with 128 units.
* This should be followed with four dense layers, each with 64 units.
* All of these Dense layers should use the ReLU activation function.
* The output Dense layer should have 3 units and the softmax activation function.

In total, the network should have 10 layers.
"""

def get_model(input_data):
    """
    This function should build a Sequential model according to the above specification. Ensure the 
    weights are initialised by providing the input_shape argument in the first layer, given by the
    function argument.
    Your function should return the model.
    """
    model = Sequential([
                        Dense(64, input_shape = (input_data.shape[1],),
                              activation = "relu", 
                              kernel_regularizer = regularizers.l2(.01),
                              kernel_initializer = tf.keras.initializers.HeUniform(), 
                              bias_initializer = "ones"
                              ),
                        Dense(128, activation = "relu"),
                        Dense(128, activation = "relu"),
                        Dense(128, activation = "relu"),
                        Dense(128, activation = "relu"),
                        Dense(64, activation = "relu"),
                        Dense(64, activation = "relu"),
                        Dense(64, activation = "relu"),
                        Dense(64, activation = "relu"),
                        Dense(1, activation = 'sigmoid')
                        #Dense(1, activation = "softmax")
    ])
    return model

# Run your function to get the model

model = get_model(train_data)

"""#### Compile the model

You should now compile the model using the `compile` method. Remember that you need to specify an optimizer, a loss function and a metric to judge the performance of your model.
"""

#
def compile_model(model):
    """
    This function takes in the model returned from your get_model function, and compiles it with an optimiser,
    loss function and metric.
    Compile the model using the Adam optimiser (with learning rate set to 0.0001), 
    the categorical crossentropy loss function and accuracy as the only metric. 
    Your function doesn't need to return anything; the model will be compiled in-place.
    """
    
    model.compile(optimizer = tf.keras.optimizers.Adam(learning_rate=0.0001), loss = "BinaryCrossentropy", metrics =  ["binary_accuracy"])

# Run your function to compile the model

compile_model(model)
model.summary()

"""#### Fit the model to the training data

Now you should train the model on the Iris dataset, using the model's `fit` method. 
* Run the training for a fixed number of epochs, given by the function's `epochs` argument.
* Return the training history to be used for plotting the learning curves.
* Set the batch size to 40.
* Set the validation set to be 15% of the training set.
"""

def train_model(model, train_data, train_targets, epochs):
    """
    This function should train the model for the given number of epochs on the 
    train_data and train_targets. 
    Your function should return the training history, as returned by model.fit.
    """
    return model.fit(train_data, train_targets, epochs = epochs, validation_split = 0.15, batch_size = 40, verbose=1)

"""Run the following cell to run the training for 800 epochs."""

# Run your function to train the model

history = train_model(model, train_data, train_targets, epochs=500)



"""Oh no! We have overfit our dataset. You should now try to now try to mitigate this overfitting.

#### Reducing overfitting in the model

You should now define a new regularised model.
The specs for the regularised model are the same as our original model, with the addition of two dropout layers, weight decay, and a batch normalisation layer. 

In particular:

* Add a dropout layer after the 3rd Dense layer
* Then there should be two more Dense layers with 128 units before a batch normalisation layer
* Following this, two more Dense layers with 64 units and then another Dropout layer
* Two more Dense layers with 64 units and then the final 3-way softmax layer
* Add weight decay (l2 kernel regularisation) in all Dense layers except the final softmax layer
"""

def get_regularised_model(input_data, dropout_rate, weight_decay):
    """
    This function should build a regularised Sequential model according to the above specification. 
    The dropout_rate argument in the function should be used to set the Dropout rate for all Dropout layers.
    L2 kernel regularisation (weight decay) should be added using the weight_decay argument to 
    set the weight decay coefficient in all Dense layers that use L2 regularisation.
    Ensure the weights are initialised by providing the input_shape argument in the first layer, given by the
    function argument input_shape.
    Your function should return the model.
    """
    model = Sequential([
                        Dense(64, input_shape = (input_data.shape[1],), activation = "relu", kernel_initializer = tf.keras.initializers.HeUniform(), bias_initializer = "ones"),
                        Dense(128, activation = "relu", kernel_regularizer = regularizers.l2(weight_decay) ),
                        Dense(128, activation = "relu", kernel_regularizer = regularizers.l2(weight_decay) ),
                        Dropout(dropout_rate),
                        Dense(128, activation = "relu", kernel_regularizer = regularizers.l2(weight_decay) ),
                        Dense(128, activation = "relu", kernel_regularizer = regularizers.l2(weight_decay) ),
                        BatchNormalization(),
                        Dense(64, activation = "relu", kernel_regularizer = regularizers.l2(weight_decay) ),
                        Dense(64, activation = "relu", kernel_regularizer = regularizers.l2(weight_decay) ),
                        Dropout(dropout_rate),
                        Dense(64, activation = "relu", kernel_regularizer = regularizers.l2(weight_decay) ),
                        Dense(64, activation = "relu", kernel_regularizer = regularizers.l2(weight_decay) ),
                        #Dense(3, activation = "softmax")
                        Dense(1, activation = 'sigmoid')
    ])
    return model

"""#### Instantiate, compile and train the model"""

# Instantiate the model, using a dropout rate of 0.3 and weight decay coefficient of 0.001

reg_model = get_regularised_model(train_data, 0.8, 0.001)

# Compile the model

compile_model(reg_model)

reg_model.summary()

# Train the model
reg_history = train_model(reg_model, train_data, train_targets, epochs=2000)

"""#### Plot the learning curves

Let's now plot the loss and accuracy for the training and validation sets.
"""

# Evaluate the model on the test set
test_loss, test_acc = model.evaluate(test_data, test_targets, verbose=1)
print("\nNo Regularization \nTest loss: {:.3f}\nTest accuracy: {:.2f}%\n".format(test_loss, 100 * test_acc))

test_loss, test_acc = reg_model.evaluate(test_data, test_targets, verbose=1)
print("\nWith Regularization \nTest loss: {:.3f}\nTest accuracy: {:.2f}%\n".format(test_loss, 100 * test_acc))

fig, axs = plt.subplots(2, 2)

#axs[0, 0].plot(x, y)
#axs[0, 0].set_title("main")
try:
    axs[0, 0].plot(history.history['binary_accuracy'])
    axs[0, 0].plot(history.history['val_binary_accuracy'])
except KeyError:
    axs[0, 0].plot(history.history['acc'])
    axs[0, 0].plot(history.history['val_acc'])
axs[0, 0].set_title('No Reg Accuracy vs. epochs')
axs[0, 0].set_ylabel('Accuracy')
axs[0, 0].set_xlabel('Epoch')
axs[0, 0].legend(['Training', 'Validation'], loc='lower right')

#axs[1, 0].plot(x, y**2)
#axs[1, 0].set_title("shares x with main")
#axs[1, 0].sharex(axs[0, 0])
axs[1, 0].plot(history.history['loss'])
axs[1, 0].plot(history.history['val_loss'])
axs[1, 0].set_title('No Reg Loss vs. epochs')
axs[1, 0].set_ylabel('Loss')
axs[1, 0].set_xlabel('Epoch')
axs[1, 0].legend(['Training', 'Validation'], loc='upper right')

#axs[0, 1].plot(x + 1, y + 1)
#axs[0, 1].set_title("unrelated")
try:
    axs[0, 1].plot(reg_history.history['binary_accuracy'])
    axs[0, 1].plot(reg_history.history['val_binary_accuracy'])
except KeyError:
    axs[0, 1].plot(reg_history.history['acc'])
    axs[0, 1].plot(reg_history.history['val_acc'])
axs[0, 1].set_title('With Reg Accuracy vs. epochs')
axs[0, 1].set_ylabel('Accuracy')
axs[0, 1].set_xlabel('Epoch')
axs[0, 1].legend(['Training', 'Validation'], loc='lower right')

#axs[1, 1].plot(x + 2, y + 2)
#axs[1, 1].set_title("also unrelated")
axs[1, 1].plot(reg_history.history['loss'])
axs[1, 1].plot(reg_history.history['val_loss'])
axs[1, 1].set_title('With Reg Loss vs. epochs')
axs[1, 1].set_ylabel('Loss')
axs[1, 1].set_xlabel('Epoch')
axs[1, 1].legend(['Training', 'Validation'], loc='upper right')

fig.tight_layout()
plt.show()